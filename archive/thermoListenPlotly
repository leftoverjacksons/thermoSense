import serial
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from collections import deque
import numpy as np
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import time

app = dash.Dash(__name__, suppress_callback_exceptions=True)

COLORS = {
    'background': '#1a1a1a',
    'text': '#ffffff',
    'grid': '#333333',
    'voltage': '#00ff00',
    'pressure': '#ff4444',
    'paper': '#2d2d2d'
}

class PressureMonitor:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, window_size=100):
        if not hasattr(self, 'initialized'):
            print("Starting initialization...")
            self.voltage_data = deque(maxlen=window_size)
            self.pressure_data = deque(maxlen=window_size)
            self.timestamps = deque(maxlen=window_size)
            self.window_size = window_size
            self.ser = None
            # Track maximum values
            self.max_voltage = 5.0  # Start with default
            self.max_pressure = 0.0  # Will be updated dynamically
            self.connect_serial()
            self.initialized = True
            print("Initialization complete")

    def connect_serial(self):
        if self.ser is None or not self.ser.is_open:
            try:
                self.ser = serial.Serial()
                self.ser.port = 'COM4'
                self.ser.baudrate = 115200
                self.ser.timeout = 0.1
                self.ser.writeTimeout = 0.1
                self.ser.open()
                
                print(f"Connected to {self.ser.name}")
                print(f"Port settings: {self.ser.get_settings()}")
                
                time.sleep(2)
                self.ser.reset_input_buffer()
                
            except serial.SerialException as e:
                print(f"Error opening serial port: {e}")
                self.ser = None

    def read_serial(self):
        if self.ser and self.ser.is_open and self.ser.in_waiting:
            try:
                data = self.ser.read(self.ser.in_waiting).decode('ascii')
                for line in data.split('\n'):
                    if "DATA:" in line:
                        try:
                            _, voltage_str, pressure_str = line.strip().split(':')
                            voltage = float(voltage_str)
                            pressure = float(pressure_str)
                            
                            # Update maximum values
                            self.max_voltage = max(self.max_voltage, voltage)
                            self.max_pressure = max(self.max_pressure, pressure)
                            
                            self.voltage_data.append(voltage)
                            self.pressure_data.append(pressure)
                            self.timestamps.append(time.time())
                            
                        except (ValueError, IndexError) as e:
                            print(f"Error parsing line '{line}': {e}")
            except Exception as e:
                print(f"Error reading serial: {e}")
                self.connect_serial()

    def cleanup(self):
        if self.ser and self.ser.is_open:
            self.ser.close()
            print("Serial connection closed")

# Initialize the monitor
monitor = PressureMonitor(window_size=100)

app.layout = html.Div([
    html.H1(
        'Pressure Sensor Monitoring',
        style={
            'textAlign': 'center',
            'color': COLORS['text'],
            'fontFamily': 'Arial',
            'padding': '20px',
            'backgroundColor': COLORS['paper'],
            'margin': '0px',
            'borderRadius': '5px'
        }
    ),
    
    html.Div([
        dcc.Graph(
            id='live-graph',
            style={
                'height': '800px',
                'backgroundColor': COLORS['background'],
                'padding': '20px',
                'borderRadius': '5px'
            }
        ),
    ], style={
        'backgroundColor': COLORS['background'],
        'padding': '20px',
        'margin': '20px',
        'borderRadius': '10px',
        'boxShadow': '0px 0px 10px rgba(0,0,0,0.5)'
    }),
    
    dcc.Interval(
        id='graph-update',
        interval=100,
        n_intervals=0
    )
], style={'backgroundColor': COLORS['background'], 'margin': '0px', 'padding': '20px'})

@app.callback(
    Output('live-graph', 'figure'),
    [Input('graph-update', 'n_intervals')]
)
def update_graph(n):
    monitor.read_serial()
    
    fig = make_subplots(
        rows=2, 
        cols=1,
        subplot_titles=(
            '<b>Voltage Reading</b>',
            '<b>Pressure Reading</b>'
        ),
        vertical_spacing=0.15
    )
    
    # Add voltage trace
    fig.add_trace(
        go.Scatter(
            y=list(monitor.voltage_data),
            mode='lines',
            name='Voltage',
            line=dict(
                color=COLORS['voltage'],
                width=3,
                shape='spline'
            ),
            fill='tozeroy',
            fillcolor=f'rgba(0, 255, 0, 0.1)'
        ),
        row=1, col=1
    )
    
    # Add pressure trace
    fig.add_trace(
        go.Scatter(
            y=list(monitor.pressure_data),
            mode='lines',
            name='Pressure',
            line=dict(
                color=COLORS['pressure'],
                width=3,
                shape='spline'
            ),
            fill='tozeroy',
            fillcolor=f'rgba(255, 68, 68, 0.1)'
        ),
        row=2, col=1
    )
    
    # Update layout with improved dark mode styling
    fig.update_layout(
        height=800,
        showlegend=True,
        paper_bgcolor=COLORS['paper'],
        plot_bgcolor=COLORS['background'],
        font=dict(color=COLORS['text']),
        margin=dict(l=50, r=50, t=30, b=30),
        legend=dict(
            bgcolor=COLORS['paper'],
            bordercolor=COLORS['text'],
            borderwidth=1
        ),
        title_font=dict(size=24),
    )
    
    # Update axes
    fig.update_xaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor=COLORS['grid'],
        zeroline=False,
        showline=True,
        linewidth=2,
        linecolor=COLORS['grid']
    )
    
    # Set dynamic ranges for y-axes
    voltage_range = [0, max(5.0, monitor.max_voltage * 1.1)]  # At least 5V, or 10% above max
    pressure_range = [0, max(200.0, monitor.max_pressure * 1.1)]  # At least 200 PSI, or 10% above max
    
    fig.update_yaxes(
        title_text='Voltage (V)',
        range=voltage_range,
        row=1, col=1,
        showgrid=True,
        gridwidth=1,
        gridcolor=COLORS['grid'],
        zeroline=False,
        showline=True,
        linewidth=2,
        linecolor=COLORS['grid']
    )
    
    fig.update_yaxes(
        title_text='Pressure (PSI)',
        range=pressure_range,
        row=2, col=1,
        showgrid=True,
        gridwidth=1,
        gridcolor=COLORS['grid'],
        zeroline=False,
        showline=True,
        linewidth=2,
        linecolor=COLORS['grid']
    )
    
    # Add current value annotations
    if monitor.voltage_data and monitor.pressure_data:
        latest_voltage = monitor.voltage_data[-1]
        latest_pressure = monitor.pressure_data[-1]
        
        fig.add_annotation(
            text=f"<b>Current: {latest_voltage:.3f}V</b><br>Max: {monitor.max_voltage:.3f}V",
            xref="paper", yref="paper",
            x=1.02, y=0.5,
            xanchor="left",
            font=dict(size=16, color=COLORS['voltage']),
            showarrow=False,
            row=1, col=1
        )
        
        fig.add_annotation(
            text=f"<b>Current: {latest_pressure:.1f}PSI</b><br>Max: {monitor.max_pressure:.1f}PSI",
            xref="paper", yref="paper",
            x=1.02, y=0.0,
            xanchor="left",
            font=dict(size=16, color=COLORS['pressure']),
            showarrow=False,
            row=2, col=1
        )
    
    return fig

if __name__ == '__main__':
    try:
        app.run_server(debug=False)
    finally:
        monitor.cleanup()